<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"zeptrion-api_index.js.html":{"id":"zeptrion-api_index.js.html","title":"Source: zeptrion-api/index.js","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Source: zeptrion-api/index.js &quot;use strict&quot;; // Error-errno 1200 // 1202 = User Input Error // 1201 = User Input Error // 1221 = EHOSTUNREACH (404 Error) // 1222 = EHOSTUNREACH (Timeout Error) // 1223 = EHOSTUNREACH (Not reachable Error) // 1224 = xml2js_PARSER_ERROR // 1299 = undefined error var Q = require(&quot;Q&quot;), errors = require(&quot;./errors&quot;), xml2js = require('xml2js'), air_creater = require(&quot;./air_creater&quot;); function Air(config_promise, host_ip, port) { this.config_promise = config_promise; this.config = {}; this.port = port; this.url = &quot;http://&quot; + host_ip + &quot;:&quot; + port; } /** * Makes an ZeptrionAir Devices API (Air) and returns the promise to it * @param Object = {host_ip:&quot;&quot;, port:&quot;&quot;, timeout:&quot;&quot;} or only the host_ip * --&gt; host_ip (mandatory)(ip of the ZeptrionAir Device) * --&gt; port (optional) (port of the ZeptrionAir Device --&gt; or 80 if not set) * --&gt; timeout (optional) (timeout in millisecond for the call to the ZeptrionAir Device to get all information --&gt; or 1000 if not set) * --&gt; test (!!! only for tests, you need to know what you are doing !!!) {} * @return return the Air Promise or rejection if error */ module.exports = function(inputs) { var air, deferred = Q.defer(), defaults = require(&quot;./default_config&quot;).defaults, has_error = false; if (!inputs || (inputs === undefined)) { deferred.reject(errors.createApiError({errno:1202})); has_error = true; } else { if (typeof inputs == &quot;string&quot;) { var host_ip = inputs; inputs = { host_ip: host_ip, port: inputs.default_port, timeout: inputs.default_timeout }; } if (&quot;test&quot; in inputs) { if (&quot;defaults&quot; in inputs.test) { defaults = inputs.test.defaults; } } inputs.defaults = defaults; if (!inputs.host_ip) { deferred.reject(errors.createApiError({errno:1201})); has_error = true; } else { if (!inputs.timeout) { inputs.timeout = inputs.defaults.default_timeout; } if (!inputs.port) { inputs.port = inputs.defaults.default_port; } var config_promise = air_creater.getAirConfigPromise(inputs); deferred.resolve(new Air(config_promise, inputs.host_ip, inputs.port)); } } return deferred.promise; }; /** * returns all the air_configs * @callback * @ */ Air.prototype.getAirConfig = function(callback) { if (&quot;ntp&quot; in this.config) { callback(null, this.config); } else { this.config_promise.then(function(results) { var new_error, configCounter = 0; for (var i = 0; i &lt; results.length; i++) { var parserE = new xml2js.Parser({ explicitArray: false }); try { parserE.parseString(results[i].data, function(err, result) { if (!new_error &amp;&amp; err) { new_error = err; } else { var temp_key = Object.keys(result); this.config[temp_key[0]] = result[temp_key[0]]; configCounter += 1; } }.bind(this)); } catch (err) { new_error = err; } } var intervalObject = setInterval(function() { if (new_error) { var new_err; var error = new_error; var new_err = errors.createApiError({file:&quot;zeptrion-api/index.js&quot;,org_error:error}); callback(new_err, null); clearInterval(intervalObject); } else if (configCounter == results.length) { if (new_error) callback(new_error); else callback(null, this.config); clearInterval(intervalObject); } }.bind(this), 0); }.bind(this), function(error) { var new_err; var new_err = errors.createApiError({file:&quot;zeptrion-api/index.js&quot;,org_error:error}); callback(new_err); }); } } × Search results Close "},"zeptrion-api_errors.js.html":{"id":"zeptrion-api_errors.js.html","title":"Source: zeptrion-api/errors.js","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Source: zeptrion-api/errors.js /** * @fileOverview Error Helper. * @author &lt;a href=&quot;mailto:swissglider@mailschweiz.com&quot;&gt;Swissglider&lt;/a&gt; * @version 0.0.1 */ /** * @example * var str = &quot;abc&quot;; * console.log(repeat(str, 3)); // abcabcabc */ &quot;use strict&quot;; var util = require('util'); var errors = require(&quot;./errors.json&quot;); /** * An Abstract base class for custom errors. * @constructor * @extends Error * @param msg The error message * @param constr The constructor to call. */ var AbstractError = function(msg, constr) { // If defined, pass the constr property to V8's captureStackTrace to clean up the output Error.captureStackTrace(this, constr || this); // If defined, store a custom error message this.message = msg || &quot;Error&quot;; }; util.inherits(AbstractError, Error); AbstractError.prototype.name = &quot;Abstract Error&quot;; /** * An Error Type for API related errors when calling the Zeptrion Airs. * @constructor ApiError * @extends AbstractError * @param {[type]} error The error object returned from the request. */ var ApiError = function(error) { var errorMessage, code, errno, syscall, org_error; errorMessage = &quot;ZEPTRION_AIR_API_ERROR: &quot; + errno + &quot; ==&gt; &quot; + errorMessage; ApiError.super_.call(this, errorMessage, this.constructor); this.type = error.code; this.code = error.code; this.errno = error.errno; this.syscall = error.syscall; this.org_error = error.org_error; if (error.address) { this.address = error.address; } }; util.inherits(ApiError, AbstractError); ApiError.prototype.name = &quot;Api Error&quot;; /** * [createApiError description] * @method createApiError * @param {[type]} error_conf [description] * @return {ApiError} [description] */ function createApiError(error_conf) { if (&quot;errno&quot; in error_conf) { return _getCorrectError(error_conf); } var error_descs = errors.APIError, error_desc_keys = Object.keys(error_descs); error_conf.errno = 9999; for (var i = 0; i &lt; error_desc_keys.length; i++) { var error_desc = error_descs[error_desc_keys[i]]; if (!(typeof error_desc == &quot;string&quot;) &amp;&amp; (&quot;file&quot; in error_desc) &amp;&amp; (&quot;file&quot; in error_conf) &amp;&amp; (error_desc.file == error_conf.file)) { if ((&quot;search_string&quot; in error_desc) &amp;&amp; (error_conf.org_error.toString().indexOf(error_desc.search_string) !== -1)) { error_conf.errno = parseInt(error_desc_keys[i]); } } } return _getCorrectError(error_conf); } module.exports.createApiError = createApiError; /** * [_getCorrectError description] * @method _getCorrectError * @param {[type]} error_conf [description] * @return {[type]} [description] * @private */ function _getCorrectError(error_conf) { var error_desc = errors.APIError[error_conf.errno]; return new ApiError({ code: error_desc.code || error_conf.org_error.code, description: error_desc.description || error_conf.org_error.toString(), errno: error_conf.errno, syscall: error_desc.syscall || error_conf.org_error.syscall, org_error: error_conf.org_error }); } × Search results Close "},"zeptrion-api_air_search.js.html":{"id":"zeptrion-api_air_search.js.html","title":"Source: zeptrion-api/air_search.js","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Source: zeptrion-api/air_search.js var mdns = require('mdns'), util = require('util'), EventEmitter = require('events').EventEmitter, airAPI = require(&quot;./&quot;); /** * Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanning * The AirLocator sents the following events: * @event start if the Scanner starts scanning * @event serviceUp if a new Air has registered on the mDNS Service * @event serviceDown if the Air has deregistered on the mDNS Service * @event stop if the Scanner stops scanning * @return returns a AirLocator */ var startAirLocator = function() { return new AirLocator(); } module.exports.startAirLocator = startAirLocator; /** * Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanning * The AirLocator sents the following events: * @event start if the Scanner starts scanning * @event serviceUp if a new Air has registered on the mDNS Service and sent the Air promise with the event * @event serviceDown if the Air has deregistered on the mDNS Service and sent the Air promise with the event * @event stop if the Scanner stops scanning * @event error if the Scanner stops scanning and sent the error with the event * The AirLocator has the following Methods: * @method startScanning() starts scanning * @method getAllFoundAirs() return all already found airs during scanning * @method stopScanning() stops scanning */ var AirLocator = function() { this.airs = {}; this.browser = mdns.createBrowser(mdns.tcp('zapp')); this.startScanning(); var self = this; EventEmitter.call(this); } util.inherits(AirLocator, EventEmitter); /** * starts scanning */ AirLocator.prototype.startScanning = function() { this.emit('start'); this.browser.on('serviceUp', function(service) { var air_promise = airAPI(service.addresses[0]); this.emit('serviceUp', air_promise); this.airs[service.name] = air_promise; }.bind(this)); this.browser.on(&quot;serviceDown&quot;, function(service) { if(service.name in this.airs){ air_promise = this.airs[service.name]; this.emit('serviceDown', air_promise); delete this.airs[service.name]; } }.bind(this)); this.browser.start(); } /** * return all already found airs (promise) in an Array during scanning */ AirLocator.prototype.getAllFoundAirs = function(){ return Object.getValues(this.airs); } /** * stops scanning */ AirLocator.prototype.stopScanning = function() { this.browser.stop(); this.emit('stop'); } × Search results Close "},"zeptrion-api_air_creater.js.html":{"id":"zeptrion-api_air_creater.js.html","title":"Source: zeptrion-api/air_creater.js","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Source: zeptrion-api/air_creater.js &quot;use strict&quot;; // Error-errno 1400 // 1400 = User Input Error var Q = require(&quot;Q&quot;), axios = require(&quot;axios&quot;), errors = require(&quot;./errors&quot;); /** * Makes an air_config and returns the promise to it * @param Object = {host_ip:&quot;&quot;, port:&quot;&quot;, timeout:&quot;&quot;} * --&gt; host_ip (mandatory)(ip of the ZeptrionAir Device) * --&gt; port (mandatory) (port of the ZeptrionAir Device --&gt; or 80 if not set) * --&gt; timeout (mandatory) (timeout in millisecond for the call to the ZeptrionAir Device to get all information --&gt; or 1000 if not set) * --&gt; defaults with all the default configurations * @return return the air_config Promise or rejection if error */ function getAirConfigPromise(inputs) { var deferred = Q.defer(); if (!inputs || !inputs.host_ip || inputs.timeout || !inputs.port) { deferred.reject(errors.createApiError({errno:1401})); } var path_keys = Object.keys(inputs.defaults.default_path), call_functions = [], base_path = &quot;http://&quot; + inputs.host_ip + &quot;:&quot; + inputs.port, getResult = function(path) { return axios.get(base_path + path,{timeout:inputs.timeout}); }; for (var i = 0; i &lt; path_keys.length; i++) { call_functions.push(getResult(inputs.defaults.default_path[path_keys[i]])); } var config_promise = axios.all(call_functions); return config_promise; } module.exports.getAirConfigPromise = getAirConfigPromise; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Source: index.js &quot;use strict&quot;; // // This wrapper is to provide some continuity in the modifications of the APIs over time // var searchAirs = require(&quot;./zeptrion-api/air_search&quot;); var Zeptrion = require(&quot;./zeptrion-api&quot;); //var lightState = require(&quot;./zeptrion-api/lightstate&quot;); //var scheduledEvent = require(&quot;./zeptrion-api/scheduledEvent&quot;); //var scene = require(&quot;./zeptrion-api/scene&quot;); //var timer = require(&quot;./zeptrion-api/timer&quot;); var ApiError = require(&quot;./zeptrion-api/errors&quot;).ApiError; module.exports = { ZeptrionApi: Zeptrion, AirAPI: Zeptrion, air: Zeptrion, api: Zeptrion, //lightState: lightState, //scheduledEvent: scheduledEvent, //scene: scene, //timer: timer, /** * Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanning * The AirLocator sents the following events: * @event start if the Scanner starts scanning * @event serviceUp if a new Air has registered on the mDNS Service and sent the Air with the event * @event serviceDown if the Air has deregistered on the mDNS Service and sent the Air with the event * @event stop if the Scanner stops scanning * @event error if the Scanner stops scanning and sent the error with the event * The AirLocator has the following Methods: * @method startScanning() starts scanning * @method getAllFoundAirs() return all already found airs during scanning * @method stopScanning() stops scanning */ airRunningLocator: searchAirs.startAirLocator, ApiError: ApiError }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Global Methods createApiError() [createApiError description] Parameters: Type Description Source: zeptrion-api/errors.js, line 65 Returns: [description] Type ApiError getAirConfigPromise(inputs) Makes an air_config and returns the promise to it Parameters: Name Type Description inputs Source: zeptrion-api/air_creater.js, line 18 Returns: return the air_config Promise or rejection if error stopScanning() stops scanning() Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanningThe AirLocator sents the following events: Source: zeptrion-api/air_search.js, line 20 stopScanning() stops scanning() Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanningThe AirLocator sents the following events: Source: index.js, line 27 Type Definitions @() returns all the air_configs Source: zeptrion-api/index.js, line 74 Events stop if the Scanner stops scanning Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanningThe AirLocator sents the following events: Source: zeptrion-api/air_search.js, line 6 Returns: returns a AirLocator × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Classes Classes AbstractError ApiError Events stop if the Scanner stops scanning Returns a new AirLocator that is looking up for ZeptreonAir Devices (Airs) with help of mDNS on the Network and start scanningThe AirLocator sents the following events: Source: zeptrion-api/air_search.js, line 6 Returns: returns a AirLocator × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Index zeptrion-api/errors.js Error Helper. Version: 0.0.1 Author: &lt;a href=&quot;mailto:swissglider@mailschweiz.com&quot;&gt;Swissglider&lt;/a&gt; Source: zeptrion-api/errors.js, line 1 × Search results Close "},"AbstractError.html":{"id":"AbstractError.html","title":"Class: AbstractError","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Class: AbstractError AbstractError new AbstractError(msg, constr) An Abstract base class for custom errors. Parameters: Name Type Description msg The error message constr The constructor to call. Source: zeptrion-api/errors.js, line 25 Extends Error × Search results Close "},"ApiError.html":{"id":"ApiError.html","title":"Class: ApiError","body":" DocStrap Classes AbstractErrorApiError Events event:stop if the Scanner stops scanning Global createApiErrorgetAirConfigPromisestopScanning() stops scanning Class: ApiError ApiError new ApiError() An Error Type for API related errors when calling the Zeptrion Airs. Parameters: Type Description Source: zeptrion-api/errors.js, line 35 Extends AbstractError × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
